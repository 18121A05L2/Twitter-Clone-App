-> Variables , Types ( value and referene types , complex type (string), user defined ) , Functions , 
   Visibility , Modifiers , Custom Modifiers , constructors , global variables , operators , conditionals , Arrays , Mappings , Structs , Events , Ether , Errors , Inheritance , calling other functions , interface
-> receive , fallback , call , send , transfer , payable , enums
—> stack is the local variable ( cheapest of all variables )
—> calldata was the temp variable that can't be modified, memory was the temp variable that can be modified in the function execution 
-> Data location can only be specified for arrays ,structs or mappings ( a string is an array or bytes )
—> we can't add state variable in libraries
—> new address[](size) - dynamic arrays in Solidity are initialised with default values ( here zero addresses )
—> Solidity is a synchronous language
—> for an external call always has calldata ( which stores parameters )
—> internal functions can only have references , it wont need callldata or memory
—> function modifiers can be inefficient ( repetitive code copy )
-> safemath and libraries , what are checked and unchecked
-> in Solidity in order to send native blockchain tokens like etherem , you can only work with payable address to do that 
-> enums , events , try catch , function selectors , abi encode and decode , hashing and assembly
-> what does it mean by data is empy with respective to receive and fallback
-> bash scription ( basic knowledge)
-> Ether in Solidity has 18 decimal places
--> Public: Accessible everywhere; includes an automatic getter for variables.
    Private: Accessible only within the contract where it is defined; not visible to derived contracts.
    Internal: Accessible within the contract and by derived contracts; not visible externally.
    External: Functions accessible only from outside the contract; variables cannot have external visibility.
-> Enums in Solidity are simply a way to give names to a set of integer values, and these names are internally mapped to unsigned integers starting from 0.
-> enum: User-defined types for creating a set of named constants
-> different Data types : value types - uint, int, bool ,address ,enum, bytes , and reference types - strings, arrays, mappings, structs
-> address: Holds a 20 byte value (size of an Ethereum address).
-> function (<parameter types>) {internal|external} [pure|view|payable] [returns (<return types>)]
-> Data location : memory (whose lifetime is limited to an external function call), storage (the location where the state variables are stored, where the lifetime is limited to the lifetime of a contract) or calldata (special data location that contains the function arguments).
-> Data location can only be specified for array, struct or mapping types.
-> type(int256).min , type(I).interfaceId , bytes1 a = 0xb5; //  [10110101] , 
-> EIP-165 is a standard that enables smart contracts to declare the interfaces they implement. The interface identifier for an interface like IERC20 is derived by XORing all of the function selectors in that interface. This identifier is stored as type(IERC20).interfaceId and helps other contracts verify that a given contract implements IERC20 without needing to know the implementation details
-> For example, if a function is defined as function transfer(address to, uint256 amount), its signature is "transfer(address,uint256)". The function selector is then the first 4 bytes of the Keccak-256 hash of this signature
-> In Solidity, when you define a public state variable of a struct type, the compiler automatically generates a "getter" function for you. However, if your struct contains dynamic arrays (such as address[], uint256[], etc.), the default getter cannot provide a complete representation of the struct - why we have this exception in solidity as reading data from blockchain is free
-> Mappings are not iterable because keys are not stored in a specific order or as a list
-> mappings are implemented in Solidity—they are not iterable or copyable since their data structure resides only in storage and not in memory.
-> Member "push" is not available in address[] memory outside of storage ? - In Solidity, the push method is only available for dynamic storage arrays. It is not available for arrays declared in memory because memory arrays are fixed in size when they are created, even if they are declared as dynamic. This is a key design of Solidity to optimize performance and avoid dynamic memory allocation during execution
-> if you define variables in Solidity without explicitly specifying their visibility, they are private
-> uint256 test = uint256(1) / uint256(37); --> return value is zero why 
     - Solidity uses integer arithmetic, so division always truncates toward zero.
     - To retain precision, scale values before performing the division.
-> When a transaction reverts:
     - All state changes made during the transaction are undone.
     - Events emitted during the transaction are also discarded.
     - The transaction is effectively as if it never happened.
-> in Upgradable smart contracts ( in implementation contracts we can add new varialbles but can't reorder the existing storage variables)
-> EIP - 2535 Diamond proxy pattern
-> Proxy patterns ( https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies)
     - Unstructured Storage Proxies
     - Beacon contract address in EIP-1967 ( Beacon Proxy pattern ) - It simplifies the upgrade process for multiple proxies by centralizing the management of the implementation contract address
     - Storage Collisions between Proxy and Implementation Contracts - above EIP is the solution
     - Storage Collisions Between Implementation Versions - need to adapt to previos implementation Contracts
-> for stack too deep error in solidity , try to add variables into a struct
-> Multuply first and then to division 
-> By default, Solidity does not return 0 for non-existent indices in arrays; it throws an out-of-bounds error.
-> Event logs come with a timestamp, so there is no need to add another timestamp variable in it.
-> Bitmask for storing boolean storage variables
-> central logging contracts
-> if we want to generate addresses using number that number type must be a uint160
-> we can write custom erros and free functions outside of the smart contract too
-> with call function we can able to call functions in other smart contracts
-> keccack hash collision 
     - this will happen only when we have two dynamic data types next to each other ( string , string )



